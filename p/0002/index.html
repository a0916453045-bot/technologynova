<!doctype html>
<html lang="zh-Hans">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>STP（自我成交防止）：撮合引擎里的合规与性能平衡（摘要） | TechNova</title>
  <meta name="description" content="STP（Self-Trade Prevention）不是‘附加风控’，而是撮合事务的一部分：在不牺牲延迟与吞吐的前提下，原子化识别并阻止自我成交/刷量。本文为 TechNova 原文的中文摘要与工程要点整理。" />
  <link rel="canonical" href="https://insights.technologynova.org/p/0002/" />
  <link rel="stylesheet" href="../../assets/style.css" />
</head>
<body>
  <div class="container">
    <header>
      <p class="meta"><a href="../../">← 返回索引</a> · 2026-02-05 · <span class="badge">0002</span></p>
      <h1 class="brand" style="margin-top:8px">STP（自我成交防止）：撮合引擎里的合规与性能平衡（摘要）</h1>
      <p class="sub">原文首发于 TechNova：
        <a href="https://technologynova.org/%e4%bb%8e%e6%92%ae%e5%90%88%e5%bc%95%e6%93%8e%e5%88%b0%e5%90%88%e8%a7%84%e9%a3%8e%e6%8e%a7%ef%bc%9a%e8%87%aa%e6%88%91%e6%88%90%e4%ba%a4%e9%98%b2%e6%ad%a2%ef%bc%88stp%ef%bc%89%e6%9c%ba%e5%88%b6/">从撮合引擎到合规风控：自我成交防止（STP）机制的深度剖析与实现</a>
      </p>
      <p class="sub">承接页（交易系统解决方案）：<a href="https://technologynova.org/solution/">https://technologynova.org/solution/</a></p>
    </header>

    <div class="card">
      <div class="meta">TL;DR</div>
      <ul class="list">
        <li><b>STP 是撮合事务的一部分</b>：必须在生成成交回报前、订单簿状态更新的同一原子流程中完成判断。</li>
        <li><b>判断本身很便宜（O(1)）</b>：核心是 <code>UserID</code>（或更严格的 <code>EntityID</code>）比较；真正的坑在于内存布局与迭代删除的正确性。</li>
        <li><b>策略要可配置</b>：常见三类——取消新单、取消老单、两者都取消；不同用户（尤其做市商）偏好不同。</li>
      </ul>
    </div>

    <h2>1. STP 解决的到底是什么问题</h2>
    <p>
      自我成交（Self-Trade）指同一交易主体的买单与自己的卖单撮合。
      轻则造成手续费损失与策略“自相残杀”，重则被用于刷量（Wash Trading）操纵市场。
      因此 STP 既是合规要求，也是市场公平与用户体验的底层保障。
    </p>

    <h2>2. 为什么 STP 必须放在撮合引擎内部</h2>
    <p>
      很多人直觉是“前置风控拦掉”，但前置风控看不到订单簿的实时对手方。
      只有撮合引擎在撮合瞬间，才知道 aggressor（吃单）将与哪一笔 resting（挂单）成交。
      所以 STP 必须嵌入撮合循环：当价格条件满足准备撮合时，先做 STP 判断，再决定是否生成成交。
    </p>

    <h2>3. 策略：取消新单 / 取消老单 / 取消两者</h2>
    <div class="card">
      <ul class="list">
        <li><b>CANCEL_NEWEST</b>：取消主动吃单（新单）。默认最常见，实现也最直观。</li>
        <li><b>CANCEL_OLDEST</b>：取消订单簿上的挂单（老单）。做市商常更偏好这种，保护其挂单流动性布局。</li>
        <li><b>CANCEL_BOTH</b>：两者都撤。用于更严格的防刷量/合规模式。</li>
      </ul>
      <p class="meta">工程要点：如果你在迭代订单簿时删除元素，必须用“可安全删除”的迭代器/数据结构，否则很容易出隐蔽 bug。</p>
    </div>

    <h2>4. 性能与实现：关键不在 if，而在数据局部性</h2>
    <ul class="list">
      <li><b>字段内联</b>：把 <code>UserID</code>（最好是 <code>uint64</code>）直接放进 Order 结构体，避免指针跳转导致 cache miss。</li>
      <li><b>只在“价格可交叉”时检查</b>：别为了 STP 去扫描订单簿。</li>
      <li><b>单交易对单线程事件循环</b>更自然：撮合+STP 原子化，避免锁与并发写订单簿的复杂度。</li>
    </ul>

    <h2>5. 架构演进：从 UserID 到 EntityID（更严格但仍要 O(1)）</h2>
    <p>
      当监管要求提升到“同一最终受益人（UBO）旗下多账户也禁止自成交”，就不能只比 UserID。
      推荐做法是：在订单进入撮合引擎之前完成“身份丰富化”（UserID → EntityID），让撮合环路里仍然是 O(1) 比较。
      <b>反模式</b>是在撮合循环里 RPC 调用外部合规服务——那会把延迟直接炸穿。
    </p>

    <hr />
    <div class="card">
      <div class="meta">延伸阅读 / 合作</div>
      <p>
        如果你正在规划撮合引擎、风控、清结算、账户体系等模块的落地，可参考 TechNova 的交易系统整体解决方案：
        <a href="https://technologynova.org/solution/">https://technologynova.org/solution/</a>
      </p>
      <p class="meta">原文链接：<br/>
        <a href="https://technologynova.org/%e4%bb%8e%e6%92%ae%e5%90%88%e5%bc%95%e6%93%8e%e5%88%b0%e5%90%88%e8%a7%84%e9%a3%8e%e6%8e%a7%ef%bc%9a%e8%87%aa%e6%88%91%e6%88%90%e4%ba%a4%e9%98%b2%e6%ad%a2%ef%bc%88stp%ef%bc%89%e6%9c%ba%e5%88%b6/">https://technologynova.org/…/</a>
      </p>
    </div>

    <div class="footer">
      <div>本页为中文摘要与工程要点整理，非原文全文；原文版权归 TechNova 所有。</div>
    </div>
  </div>
</body>
</html>
